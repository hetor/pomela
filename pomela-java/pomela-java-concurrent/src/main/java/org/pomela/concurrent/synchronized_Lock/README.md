1.原子性：
   1)Java线程中一个错误的知识——原子操作不需要进行同步控制，依赖于原子性是很棘手且很危险的;
   2)原子操作可由线程机制来保证其不可中断，专家级的程序员可以利用这一点来编写无锁的代码，这些代码不需要被同步，但即便这样它也是一种不太安全的机制;
   3)除long和double之外的基本类型的读写操作是原子操作，java中递增不是原子性操作.

2.synchronized关键字
   1)每个对象都自动含有单一的锁（监视器），synchronized方法锁住对象;
   2)每个类的Class对象也含有一把锁，所以synchronized static方法可以在类的范围内防止对static数据的并发访问;
   3)一个任务可以多次获得对象的锁，JVM负责跟踪对象被加锁的次数，每当任务离开一个synchronized方法计数减1，计数为0时对象被解锁;
   4)synchronized不属于方法特征签名的组成部分，所以可以在覆盖方法的时候加上去.
   5)synchronized块必须指定一个在其上进行同步的对象，最合理的是使用其方法正在被调用的对象synchronized(this)，有时必须在另一个对象上
   同步，如果要这么做，就必须保证所有相关的任务都是在同一个对象上同步的。

3.volatile:
   1)保证可视性,保证写操作刷新到主存（synchronized也可以做到，因此一个域由synchronized方法或语句块防护就不必将其设置为volatile）;
   2)使用volatile关键字的long或double变量会获得赋值与返回操作的原子性，volatile不能对递增不是原子性操作这一事实产生影响;
   3)使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域，第一选择且最安全的方式应该是使用synchronized，
   尝试其它任何方式都是有风险的.

4.《Java Concurrency in Practice》作者Brain的同步规则：
   如果你正在写一个变量，它可能接下来将被另一个线程读取，或者正在读取一个上一次已经被另一个线程写过的变量，那么你必须使用同步，
   并且，读写线程都必须用相同的监视器锁同步.
   
5.Lock与Synchronized对比：
   1)显式的Lock对象必须被显示地创建、锁定和释放，与内建的锁形式相比，代码缺乏优雅性;
   2)使用synchronized时，某些事物失败了就会抛出一个异常，但是你没有机会去做任何清理工作以维护系统使其处于良好状态，
   显式的Lock对象就可以使用finally子句将系统维护在正常的状态了;
   3)使用synchronized时代码量更少，用户错误的可能性也降低;
   4)只有在解决特殊问题时才使用Lock对象，比如用synchronized不能尝试获取锁且最终获取锁失败，或者尝试着获取锁一段时间，然后放弃它.

原子类：AtomicInteger, AtomicLong, AtomicReference等特殊的原子性变量类。
Atomic类被设计用来构建java.util.concurrent中的类，因此只有在特殊的情况下才在自己的代码中使用它们，即便使用了也需要确保不存在其他可能出现的问题，
通常，依赖于锁更安全（synchronized关键字, Lock对象）

同一个互斥锁可以被同一个任务多次获得

6.临界区：防止多个线程同时访问方法内部的部分代码，这种分离出来的代码段被称为临界区.

7.java.lang.ThreadLocal——防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享.
ThreadLocal对象通常当做静态域存储。
